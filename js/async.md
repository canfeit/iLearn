## ES 单线程执行

避免多线程创建切换开销,死锁，多线程内存占用,数据同步问题

## 异步接口

- HTML5 requestAnimationFrame:动画 API,与显示器刷新频率同步,页面非活动状态动画自动暂停
- Node setImmediate:Node.js 异步 API

## CPU 计算密集

- HTML5 Web Worker:受限子线程
- Node child_process:受限子进程

## 作用域(词法环境)->定义时决定

作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。
同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中确定的，而作用域却是在函数创建时就确定了。
如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。

## 异步

- Node.js 线程:JS 引擎(V8)、线程池(libuv)
- 浏览器线程:JS 引擎、渲染引擎、HTTP 请求线程、事件处理线程、定时器线程。
  当 JS 引擎线程处于运行状态时，GUI 渲染线程将处于冻结状态。
- setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。 HTML5 标准规定了 setTimeout()的第二个参数的最小值（最短间隔），不得低于 4 毫秒，如果低于这个值，就会自动增加。在此之前，老版本的浏览器都将最短间隔设为 10 毫秒。另外，对于那些 DOM 的变动（尤其是涉及页面重新渲染的部分），通常不会立即执行，而是每 16 毫秒执行一次。这时使用 requestAnimationFrame()的效果要好于 setTimeout()。
- 需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证回调函数一定会在 setTimeout()指定的时间执行。
- 如果部署得好，JavaScript 程序是不会出现堵塞的，这就是 node.js 平台可以用很少的资源，应付大流量访问的原因。非常适合在分布式设备上运行数据密集型（事件轮询）的实时应用

1. events 事件注册
2. nextTick()的回调函数执行的优先级要高于 setImmediate();

- process.nextTick()属于 idle 观察者,setImmediate()属于 check 观察者.在每一轮循环检查中,idle 观察者先于 I/O 观察者,I/O 观察者先于 check 观察者.
- 在具体实现上,process.nextTick()的回调函数保存在一个数组中,
- setImmediate()的结果则是保存在链表中.
- 在行为上,process.nextTick()在每轮循环中会将数组中的回调函数全部执行完.
- 而 setImmediate()在每轮循环中执行链表中的一个回调函数.

3. process.nextTick < setImmediate < setTimeout
